// Check if extension context is still valid
function isExtensionContextValid() {
  try {
    return chrome.runtime && chrome.runtime.id;
  } catch (e) {
    return false;
  }
}

// Create overlay for element highlighting
function createOverlay() {
  const overlay = document.createElement('div');
  overlay.id = 'click-scrape-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.1);
    z-index: 999999;
    pointer-events: none;
    display: none;
  `;
  document.body.appendChild(overlay);
  return overlay;
}

// Create highlight box
function createHighlightBox() {
  const box = document.createElement('div');
  box.id = 'click-scrape-highlight';
  box.style.cssText = `
    position: absolute;
    border: 2px solid #0078d4;
    background: rgba(0, 120, 212, 0.1);
    pointer-events: none;
    z-index: 1000000;
    display: none;
    box-sizing: border-box;
  `;
  document.body.appendChild(box);
  return box;
}

// Create enhanced info panel with history
function createInfoPanel() {
  const panel = document.createElement('div');
  panel.id = 'click-scrape-info';
  panel.style.cssText = `
    position: fixed;
    top: 10px;
    right: 10px;
    background: #0078d4;
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-family: sans-serif;
    font-size: 12px;
    z-index: 1000001;
    width: 400px;
    max-width: 400px;
    max-height: 600px;
    display: none;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    overflow: hidden;
    cursor: move;
    user-select: none;
  `;
  
  // Add data attribute to mark this as the info panel
  panel.setAttribute('data-click-scrape-panel', 'true');
  
  panel.innerHTML = `
    <div id="panel-header" style="cursor: move; padding: 5px 0; margin: -10px -10px 10px -10px; padding: 10px; background: rgba(255,255,255,0.15); border-radius: 5px 5px 0 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.2);">
      <span style="font-weight: bold;">üîß Element Scraper Panel</span>
      <span style="font-size: 10px; opacity: 0.8; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">‚¨ç‚¨ç Drag to move</span>
    </div>
    <div id="current-element-info" style="margin-bottom: 10px;">
      <div style="font-weight: bold; margin-bottom: 5px;">üéØ Current Element</div>
      <div id="element-details"></div>
    </div>
    <div id="history-section" style="border-top: 1px solid rgba(255,255,255,0.3); padding-top: 10px; width: 100%; min-height: 200px; display: block;">
      <div style="font-weight: bold; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center;">
        <span>üìù Click History</span>
        <div>
          <button id="clear-history" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; cursor: pointer; margin-right: 5px;">Clear</button>
          <button id="close-panel" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;">Close</button>
        </div>
      </div>
      <div id="history-content" style="width: 100%; min-height: 100px; max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.1); display: block;">
        <div class="empty-state" style="text-align: center; color: rgba(255,255,255,0.7); padding: 10px; font-style: italic; font-size: 11px;">
          No elements clicked yet
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(panel);
  
  // Prevent click-through on the entire panel
  panel.addEventListener('click', (e) => {
    e.stopPropagation();
  });
  
  // Add clear history button functionality
  panel.querySelector('#clear-history').addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    if (confirm('Clear all click history?')) {
      localStorage.removeItem('clickScrapeHistory');
      loadAndDisplayHistory();
    }
    return false;
  });
  
  // Add close panel button functionality
  panel.querySelector('#close-panel').addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    // Hide the panel and stop selection mode
    panel.style.display = 'none';
    // Remove any existing selection mode
    const existingOverlay = document.getElementById('click-scrape-overlay');
    const existingHighlight = document.getElementById('click-scrape-highlight');
    if (existingOverlay) existingOverlay.remove();
    if (existingHighlight) existingHighlight.remove();
    // Remove event listeners
    document.removeEventListener('mousemove', window.clickScrapeMouseMove);
    document.removeEventListener('click', window.clickScrapeClick, true);
    document.removeEventListener('keydown', window.clickScrapeKeyDown);
    window.clickScrapeActive = false;
    return false;
  });
  
  // Add drag functionality
  let isDragging = false;
  let currentX = 0;
  let currentY = 0;
  let initialX = 0;
  let initialY = 0;
  let xOffset = 0;
  let yOffset = 0;
  let hasBeenDragged = false; // Track if panel has been dragged before
  
  const header = panel.querySelector('#panel-header');
  
  header.addEventListener('mousedown', (e) => {
    // If this is the first drag, calculate initial position from right-positioned panel
    if (!hasBeenDragged) {
      const rect = panel.getBoundingClientRect();
      currentX = rect.left;
      currentY = rect.top;
      xOffset = currentX;
      yOffset = currentY;
      hasBeenDragged = true;
      
      // Switch from right positioning to left positioning
      panel.style.right = 'auto';
      panel.style.left = currentX + 'px';
      panel.style.top = currentY + 'px';
    }
    
    initialX = e.clientX - xOffset;
    initialY = e.clientY - yOffset;
    
    if (e.target === header || header.contains(e.target)) {
      isDragging = true;
      panel.style.cursor = 'grabbing';
    }
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      e.preventDefault();
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;
      
      xOffset = currentX;
      yOffset = currentY;
      
      // Ensure panel stays within viewport
      const rect = panel.getBoundingClientRect();
      const maxX = window.innerWidth - rect.width;
      const maxY = window.innerHeight - rect.height;
      
      currentX = Math.max(0, Math.min(currentX, maxX));
      currentY = Math.max(0, Math.min(currentY, maxY));
      
      panel.style.left = currentX + 'px';
      panel.style.top = currentY + 'px';
    }
  });
  
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      panel.style.cursor = 'move';
    }
  });
  
  // Add hover tracking to disable element capturing when over panel
  let isOverPanel = false;
  
  panel.addEventListener('mouseenter', () => {
    isOverPanel = true;
    window.clickScrapePanelHover = true;
    // Hide highlight box when hovering over panel
    const highlightBox = document.getElementById('click-scrape-highlight');
    if (highlightBox) {
      highlightBox.style.display = 'none';
    }
  });
  
  panel.addEventListener('mouseleave', () => {
    isOverPanel = false;
    window.clickScrapePanelHover = false;
  });
  
  return panel;
}

// Show copy success message
function showCopySuccessMessage(selector) {
  // Find the info panel
  const infoPanel = document.getElementById('click-scrape-info');
  if (!infoPanel) return;
  
  // Create or find the message container
  let messageContainer = infoPanel.querySelector('#copy-success-message');
  if (!messageContainer) {
    messageContainer = document.createElement('div');
    messageContainer.id = 'copy-success-message';
    messageContainer.style.cssText = `
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.25);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid rgba(144, 238, 144, 0.6);
      font-size: 11px;
      font-weight: bold;
      z-index: 1000002;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      white-space: nowrap;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      backdrop-filter: blur(4px);
    `;
    infoPanel.appendChild(messageContainer);
  }
  
  // Show the message
  messageContainer.textContent = `‚úÖ Copied: ${selector.length > 30 ? selector.substring(0, 30) + '...' : selector}`;
  messageContainer.style.display = 'block';
  
  // Hide after 2 seconds
  setTimeout(() => {
    messageContainer.style.display = 'none';
  }, 2000);
}

// Local storage functions
function saveToHistory(elementData) {
  try {
    const history = JSON.parse(localStorage.getItem('clickScrapeHistory') || '[]');
    const historyItem = {
      id: Date.now(),
      timestamp: new Date().toLocaleString(),
      tagName: elementData.tagName,
      text: elementData.text,
      selector: elementData.selectors[0]?.selector || 'N/A'
    };
    
    // Add to beginning of array (most recent first)
    history.unshift(historyItem);
    
    // Keep only last 20 items
    if (history.length > 20) {
      history.splice(20);
    }
    
    localStorage.setItem('clickScrapeHistory', JSON.stringify(history));
    loadAndDisplayHistory();
  } catch (error) {
    console.error('Error saving to history:', error);
  }
}

function loadAndDisplayHistory() {
  const historyContent = document.getElementById('history-content');
  if (!historyContent) return;
  
  try {
    const history = JSON.parse(localStorage.getItem('clickScrapeHistory') || '[]');
    
    if (history.length === 0) {
      historyContent.innerHTML = '<div class="empty-state" style="text-align: center; color: rgba(255,255,255,0.7); padding: 10px; font-style: italic; font-size: 11px;">No elements clicked yet</div>';
    } else {
      const htmlContent = `
        <table style="width: 100%; font-size: 10px; border-collapse: collapse; color: white; background: transparent; table-layout: fixed;">
          <thead>
            <tr style="background: rgba(255,255,255,0.1);">
              <th style="padding: 4px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.3);">Tag</th>
              <th style="padding: 4px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.3);">Content</th>
              <th style="padding: 4px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.3);">Selector</th>
              <th style="padding: 4px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.3);">Quality</th>
              <th style="padding: 4px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.3);">Time</th>
            </tr>
          </thead>
          <tbody>
            ${history.map(item => {
              // Ê£ÄÊü•ÈÄâÊã©Âô®Ë¥®Èáè
              let quality = '';
              let qualityColor = 'rgba(255,255,255,0.8)';
              
              if (item.selector.startsWith('#')) {
                quality = 'ID ‚úÖüîí';
                qualityColor = 'rgba(144, 238, 144, 0.8)'; // ÁªøËâ≤
              } else if (item.selector.includes('data-test') || item.selector.includes('data-cy')) {
                quality = 'Test ‚úÖüîí';
                qualityColor = 'rgba(144, 238, 144, 0.8)'; // ÁªøËâ≤
              } else if (item.selector.startsWith('.') && !item.selector.includes('nth')) {
                quality = 'Class ‚úÖüîí';
                qualityColor = 'rgba(255, 255, 0, 0.8)'; // ÈªÑËâ≤
              } else if (item.selector.includes('nth')) {
                quality = 'Position ‚ö†Ô∏è';
                qualityColor = 'rgba(255, 165, 0, 0.8)'; // Ê©ôËâ≤
              } else {
                quality = 'Other ‚ö†Ô∏è';
                qualityColor = 'rgba(255, 165, 0, 0.8)'; // Ê©ôËâ≤
              }
              
              return `
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                  <td style="padding: 4px; font-weight: bold;">${item.tagName}</td>
                  <td style="padding: 4px; max-width: 60px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${item.text || '(no text)'}">${item.text ? item.text.substring(0, 15) + (item.text.length > 15 ? '...' : '') : '(no text)'}</td>
                  <td style="padding: 4px; font-family: monospace; cursor: pointer; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" class="selector-cell" data-selector="${item.selector.replace(/"/g, '&quot;')}" title="Click to copy: ${item.selector}">${item.selector}</td>
                  <td style="padding: 4px; font-size: 9px; color: ${qualityColor}; font-weight: bold;">${quality}</td>
                  <td style="padding: 4px; font-size: 9px; color: rgba(255,255,255,0.8);">${item.timestamp}</td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      `;
      
      historyContent.innerHTML = htmlContent;
      
      // Add event delegation for selector cell clicks
      historyContent.addEventListener('click', (e) => {
        if (e.target.classList.contains('selector-cell')) {
          e.preventDefault();
          e.stopPropagation();
          
          const selector = e.target.getAttribute('data-selector');
          if (selector) {
            // Copy to clipboard
            navigator.clipboard.writeText(selector).then(() => {
              // Show success message in the panel
              showCopySuccessMessage(selector);
            }).catch(err => {
              console.error('Failed to copy to clipboard:', err);
              // Fallback: show alert
              alert('Selector copied: ' + selector);
            });
          }
        }
      });
    }
  } catch (error) {
    console.error('Error loading history:', error);
    historyContent.innerHTML = '<div class="empty-state" style="text-align: center; color: rgba(255,255,255,0.7); padding: 10px; font-style: italic; font-size: 11px;">Error loading history</div>';
  }
}

// Function to check if a selector is unique on the page
function isSelectorUnique(selector) {
  try {
    const elements = document.querySelectorAll(selector);
    return elements.length === 1;
  } catch (e) {
    return false;
  }
}

// Ê£ÄÊµãÂÖÉÁ¥†ÊòØÂê¶Âú®Áõ∏‰ººÁöÑÂÖÑÂºüÂÖÉÁ¥†ÂàóË°®‰∏≠
function isElementInSimilarSiblingsList(el) {
  const parent = el.parentElement;
  if (!parent) return false;
  
  const siblings = Array.from(parent.children);
  if (siblings.length < 2) return false;
  
  // Ëé∑ÂèñÂΩìÂâçÂÖÉÁ¥†ÁöÑÂÖÑÂºüÂÖÉÁ¥†
  const sameLevelElements = siblings.filter(sibling => 
    sibling.tagName === el.tagName && sibling !== el
  );
  
  if (sameLevelElements.length === 0) return false;
  
  // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂàóË°®È°πÊàñË°®Ê†ºË°åÁ≠âÂÖ∏ÂûãÁöÑÈáçÂ§çÁªìÊûÑ
  const isListLike = /^(li|tr|td|th|option|article|section|div)$/i.test(el.tagName);
  if (isListLike && sameLevelElements.length >= 1) {
    return true;
  }
  
  // Ê£ÄÊü•ÂÖÑÂºüÂÖÉÁ¥†ÊòØÂê¶ÊúâÁõ∏‰ººÁöÑÁªìÊûÑÁâπÂæÅ
  const currentElementFeatures = getElementStructuralFeatures(el);
  const similarSiblings = sameLevelElements.filter(sibling => {
    const siblingFeatures = getElementStructuralFeatures(sibling);
    return areFeaturesStructurallySimilar(currentElementFeatures, siblingFeatures);
  });
  
  // Â¶ÇÊûúÊúâ2‰∏™ÊàñÊõ¥Â§öÁõ∏‰ººÁöÑÂÖÑÂºüÂÖÉÁ¥†ÔºåËÆ§‰∏∫ÊòØÂú®ÂàóË°®‰∏≠
  return similarSiblings.length >= 1;
}

// Ëé∑ÂèñÂÖÉÁ¥†ÁöÑÁªìÊûÑÁâπÂæÅ
function getElementStructuralFeatures(el) {
  return {
    tagName: el.tagName,
    childElementCount: el.children.length,
    hasClass: el.className && el.className.trim().length > 0,
    classNames: el.className ? el.className.trim().split(/\s+/).sort() : [],
    hasId: el.id && el.id.trim().length > 0,
    hasAttributes: el.attributes.length > 0,
    hasText: el.textContent && el.textContent.trim().length > 0,
    childTagNames: Array.from(el.children).map(child => child.tagName).sort()
  };
}

// Âà§Êñ≠‰∏§‰∏™ÂÖÉÁ¥†ÁöÑÁªìÊûÑÁâπÂæÅÊòØÂê¶Áõ∏‰ºº
function areFeaturesStructurallySimilar(features1, features2) {
  // Ê†áÁ≠æÂêçÂøÖÈ°ªÁõ∏Âêå
  if (features1.tagName !== features2.tagName) return false;
  
  // Â≠êÂÖÉÁ¥†Êï∞ÈáèÂ∑ÆÂºÇ‰∏çËÉΩÂ§™Â§ß
  const childCountDiff = Math.abs(features1.childElementCount - features2.childElementCount);
  if (childCountDiff > 2) return false;
  
  // Ëá≥Â∞ëÊúâ‰∏Ä‰∏™ÂÖ±ÂêåÁÇπÔºöÁõ∏ÂêåÁöÑclass„ÄÅÁõ∏‰ººÁöÑÂ≠êÂÖÉÁ¥†ÁªìÊûÑÁ≠â
  const hasCommonClasses = features1.classNames.some(cls => features2.classNames.includes(cls));
  const hasSimilarChildStructure = 
    features1.childTagNames.length === features2.childTagNames.length &&
    features1.childTagNames.every((tag, index) => tag === features2.childTagNames[index]);
  
  return hasCommonClasses || hasSimilarChildStructure || 
         (features1.childElementCount === features2.childElementCount);
}

// ÁîüÊàêÂü∫‰∫éÁà∂ÂÖÉÁ¥†ÂíåÁ¥¢ÂºïÁöÑÈÄâÊã©Âô®
function generateParentBasedIndexSelector(el) {
  const parent = el.parentElement;
  if (!parent) return null;
  
  const selectors = [];
  
  // ËÆ°ÁÆóÂÖÉÁ¥†Âú®ÂêåÊ†áÁ≠æÂÖÑÂºü‰∏≠ÁöÑÁ¥¢Âºï
  const siblings = Array.from(parent.children).filter(child => child.tagName === el.tagName);
  const index = siblings.indexOf(el) + 1; // CSS‰∏≠Á¥¢Âºï‰ªé1ÂºÄÂßã
  
  // ÊñπÊ°à1ÔºöÁà∂ÂÖÉÁ¥†ID + Â≠êÂÖÉÁ¥†Ê†áÁ≠æ:nth-of-type
  if (parent.id && parent.id.trim()) {
    const selector = `#${CSS.escape(parent.id)} > ${el.tagName.toLowerCase()}:nth-of-type(${index})`;
    if (isSelectorUnique(selector)) {
      selectors.push({
        type: 'Parent ID + Index',
        selector: selector,
        description: `ÈÄöËøáÁà∂ÂÖÉÁ¥†IDÂíåÁ¨¨${index}‰∏™${el.tagName.toLowerCase()}ÈÄâÊã©ÔºàÊé®ËçêÔºâ`,
        priority: 2,
        unique: true,
        stable: true
      });
    }
  }
  
  // ÊñπÊ°à2ÔºöÁà∂ÂÖÉÁ¥†class + Â≠êÂÖÉÁ¥†Ê†áÁ≠æ:nth-of-type
  if (parent.className && typeof parent.className === 'string') {
    const parentClasses = parent.className.trim().split(/\s+/).filter(c => c.length > 0);
    for (const cls of parentClasses) {
      const selector = `.${CSS.escape(cls)} > ${el.tagName.toLowerCase()}:nth-of-type(${index})`;
      if (isSelectorUnique(selector)) {
        selectors.push({
          type: 'Parent Class + Index',
          selector: selector,
          description: `ÈÄöËøáÁà∂ÂÖÉÁ¥†classÂíåÁ¨¨${index}‰∏™${el.tagName.toLowerCase()}ÈÄâÊã©`,
          priority: 3,
          unique: true,
          stable: true
        });
        break; // Âè™ÈúÄË¶Å‰∏Ä‰∏™ÊúâÊïàÁöÑclassÈÄâÊã©Âô®
      }
    }
  }
  
  // ÊñπÊ°à3ÔºöÁà∂ÂÖÉÁ¥†ÊµãËØïÂ±ûÊÄß + Â≠êÂÖÉÁ¥†Ê†áÁ≠æ:nth-of-type
  const testAttributes = ['data-testid', 'data-test', 'data-cy'];
  for (const attr of testAttributes) {
    const value = parent.getAttribute(attr);
    if (value && value.trim()) {
      const selector = `[${attr}="${CSS.escape(value)}"] > ${el.tagName.toLowerCase()}:nth-of-type(${index})`;
      if (isSelectorUnique(selector)) {
        selectors.push({
          type: 'Parent Test Attr + Index',
          selector: selector,
          description: `ÈÄöËøáÁà∂ÂÖÉÁ¥†ÊµãËØïÂ±ûÊÄßÂíåÁ¨¨${index}‰∏™${el.tagName.toLowerCase()}ÈÄâÊã©`,
          priority: 2,
          unique: true,
          stable: true
        });
        break;
      }
    }
  }
  
  // ÊñπÊ°à4ÔºöÈÄöÁî®ÁöÑ:nth-childÈÄâÊã©Âô®ÔºàÁõ∏ÂØπ‰∏çÁ®≥ÂÆöÔºâ
  const childIndex = Array.from(parent.children).indexOf(el) + 1;
  const fallbackSelector = `${parent.tagName.toLowerCase()} > ${el.tagName.toLowerCase()}:nth-child(${childIndex})`;
  selectors.push({
    type: 'Position Index',
    selector: fallbackSelector,
    description: `ÈÄöËøá‰ΩçÁΩÆÁ¥¢ÂºïÈÄâÊã©ÔºàÁ¨¨${childIndex}‰∏™Â≠êÂÖÉÁ¥†ÔºåÁõ∏ÂØπ‰∏çÁ®≥ÂÆöÔºâ`,
    priority: 8,
    unique: false,
    stable: false
  });
  
  return selectors;
}

// Êñ∞ÁöÑCSSÈÄâÊã©Âô®ÁîüÊàêÁÆóÊ≥ï - Á°Æ‰øùÂÖ®Â±ÄÂîØ‰∏ÄÊÄß
function generateMultipleSelectors(el) {
  const selectors = [];
  
  // 1. Áõ¥Êé•ÂîØ‰∏ÄÊ†áËØÜÁ¨¶Ê£ÄÊµã
  const directSelectors = generateDirectSelectors(el);
  selectors.push(...directSelectors);
  
  // Â¶ÇÊûúÂ∑≤ÁªèÊúâÂîØ‰∏ÄÁöÑÁõ¥Êé•ÈÄâÊã©Âô®ÔºåÂèØ‰ª•ÊèêÂâçËøîÂõûÔºå‰ΩÜÊàë‰ª¨ÁªßÁª≠ÁîüÊàêÂ§áÈÄâÊñπÊ°à
  
  // 2. Âü∫‰∫éÁ•ñÂÖàÁöÑÂîØ‰∏ÄË∑ØÂæÑÈÄâÊã©Âô®
  const ancestorBasedSelectors = generateAncestorBasedSelectors(el);
  selectors.push(...ancestorBasedSelectors);
  
  // 3. Â§ÑÁêÜÁõ∏‰ººÂÖÑÂºüÂÖÉÁ¥†ÁöÑÁâπÊÆäÊÉÖÂÜµ
  const siblingAwareSelectors = generateSiblingAwareSelectors(el);
  selectors.push(...siblingAwareSelectors);
  
  // 4. Â§áÈÄâÊñπÊ°àÔºöÂÆåÊï¥ÁªìÊûÑË∑ØÂæÑ
  const fallbackSelectors = generateStructuralPathSelectors(el);
  selectors.push(...fallbackSelectors);
  
  // 5. È™åËØÅÊâÄÊúâÈÄâÊã©Âô®ÁöÑÂîØ‰∏ÄÊÄßÂπ∂ÊéíÂ∫è
  return validateAndSortSelectors(selectors, el);
}

// ÁîüÊàêÁõ¥Êé•ÈÄâÊã©Âô®ÔºàID„ÄÅÂîØ‰∏ÄÂ±ûÊÄßÁ≠âÔºâ
function generateDirectSelectors(el) {
  const selectors = [];
  
  // 1.1 IDÈÄâÊã©Âô®ÔºàÊúÄ‰ºòÂÖàÔºâ
  if (el.id && el.id.trim()) {
    const idSelector = `#${CSS.escape(el.id)}`;
    if (isSelectorUnique(idSelector)) {
      selectors.push({
        type: 'ID',
        selector: idSelector,
        description: 'ÈÄöËøáIDÈÄâÊã©ÔºàÊúÄÁ®≥ÂÆöÔºåÊé®ËçêÁî®‰∫éÁà¨Ëô´Ôºâ',
        priority: 1,
        unique: true,
        stable: true,
        specificity: 100
      });
    }
  }
  
  // 1.2 ÊµãËØïÂ±ûÊÄßÈÄâÊã©Âô®
  const testAttributes = ['data-testid', 'data-test', 'data-cy', 'data-test-id', 'data-automation-id'];
  testAttributes.forEach(attr => {
    const value = el.getAttribute(attr);
    if (value && value.trim()) {
      const selector = `[${attr}="${CSS.escape(value)}"]`;
      if (isSelectorUnique(selector)) {
        selectors.push({
          type: 'Test Attribute',
          selector: selector,
          description: `ÈÄöËøáÊµãËØïÂ±ûÊÄß${attr}ÈÄâÊã©ÔºàÊé®ËçêÁî®‰∫éÁà¨Ëô´Ôºâ`,
          priority: 2,
          unique: true,
          stable: true,
          specificity: 10
        });
      }
    }
  });
  
  // 1.3 ÂÖ∂‰ªñÂîØ‰∏ÄÂ±ûÊÄßÈÄâÊã©Âô®
  const uniqueAttributes = ['name', 'aria-label', 'title', 'alt', 'href', 'src'];
  uniqueAttributes.forEach(attr => {
    const value = el.getAttribute(attr);
    if (value && value.trim()) {
      const selector = `[${attr}="${CSS.escape(value)}"]`;
      if (isSelectorUnique(selector)) {
        selectors.push({
          type: 'Unique Attribute',
          selector: selector,
          description: `ÈÄöËøá${attr}Â±ûÊÄßÈÄâÊã©`,
          priority: 3,
          unique: true,
          stable: true,
          specificity: 10
        });
      }
    }
  });
  
  // 1.4 ÂîØ‰∏ÄclassÈÄâÊã©Âô®
  if (el.className && typeof el.className === 'string') {
    const classes = el.className.trim().split(/\s+/).filter(c => c.length > 0);
    
    // Â∞ùËØïÂçï‰∏™class
    classes.forEach(cls => {
      const selector = `.${CSS.escape(cls)}`;
      if (isSelectorUnique(selector)) {
        selectors.push({
          type: 'Unique Class',
          selector: selector,
          description: `ÈÄöËøáÂîØ‰∏Äclass "${cls}" ÈÄâÊã©`,
          priority: 4,
          unique: true,
          stable: true,
          specificity: 10
        });
      }
    });
    
    // Â∞ùËØïÂ§ö‰∏™classÁªÑÂêà
    if (classes.length > 1) {
      const multiClassSelector = classes.map(cls => `.${CSS.escape(cls)}`).join('');
      if (isSelectorUnique(multiClassSelector)) {
        selectors.push({
          type: 'Multiple Classes',
          selector: multiClassSelector,
          description: `ÈÄöËøáÂ§ö‰∏™classÁªÑÂêàÈÄâÊã©`,
          priority: 4,
          unique: true,
          stable: true,
          specificity: 10 * classes.length
        });
      }
    }
  }
  
  return selectors;
}

// ÁîüÊàêÂü∫‰∫éÁ•ñÂÖàÁöÑÈÄâÊã©Âô®
function generateAncestorBasedSelectors(el) {
  const selectors = [];
  const path = [];
  let current = el;
  let foundUniqueAncestor = false;
  
  // Âêë‰∏äÈÅçÂéÜDOMÊ†ëÔºåÂØªÊâæÊúâÂîØ‰∏ÄÊ†áËØÜÁöÑÁ•ñÂÖà
  while (current && current !== document.body && path.length < 10) {
    const stepInfo = getElementStepInfo(current);
    path.unshift(stepInfo);
    
    // Ê£ÄÊü•ÂΩìÂâçË∑ØÂæÑÊòØÂê¶Â∑≤ÁªèÂîØ‰∏Ä
    if (stepInfo.isUnique) {
      foundUniqueAncestor = true;
      break;
    }
    
    current = current.parentElement;
  }
  
  // Â¶ÇÊûúÊâæÂà∞‰∫ÜÂîØ‰∏ÄÁ•ñÂÖàÔºåÊûÑÂª∫ÈÄâÊã©Âô®
  if (foundUniqueAncestor && path.length > 1) {
    const uniqueRoot = path[0];
    const pathFromRoot = path.slice(1);
    
    // ÊñπÊ°à1Ôºö‰ΩøÁî®Áõ¥Êé•Â≠êÈÄâÊã©Âô®
    const directChildSelector = uniqueRoot.selector + ' > ' + 
      pathFromRoot.map(step => step.directSelector).join(' > ');
    
    if (isSelectorUnique(directChildSelector)) {
      selectors.push({
        type: 'Ancestor Direct Path',
        selector: directChildSelector,
        description: `ÈÄöËøáÂîØ‰∏ÄÁ•ñÂÖà${uniqueRoot.type}ÁöÑÁõ¥Êé•Ë∑ØÂæÑÈÄâÊã©`,
        priority: 5,
        unique: true,
        stable: true,
        specificity: uniqueRoot.specificity + pathFromRoot.length
      });
    }
    
    // ÊñπÊ°à2Ôºö‰ΩøÁî®Âêé‰ª£ÈÄâÊã©Âô®ÔºàÊõ¥ÂÆΩÊùæÔºâ
    const descendantSelector = uniqueRoot.selector + ' ' + 
      pathFromRoot.map(step => step.flexibleSelector).join(' ');
    
    if (isSelectorUnique(descendantSelector) && descendantSelector !== directChildSelector) {
      selectors.push({
        type: 'Ancestor Descendant Path',
        selector: descendantSelector,
        description: `ÈÄöËøáÂîØ‰∏ÄÁ•ñÂÖà${uniqueRoot.type}ÁöÑÂêé‰ª£Ë∑ØÂæÑÈÄâÊã©`,
        priority: 6,
        unique: true,
        stable: true,
        specificity: uniqueRoot.specificity + pathFromRoot.length * 0.5
      });
    }
  }
  
  return selectors;
}

// Ëé∑ÂèñÂÖÉÁ¥†ÁöÑË∑ØÂæÑÊ≠•È™§‰ø°ÊÅØ
function getElementStepInfo(el) {
  const stepInfo = {
    element: el,
    tagName: el.tagName.toLowerCase(),
    isUnique: false,
    specificity: 1,
    directSelector: el.tagName.toLowerCase(),
    flexibleSelector: el.tagName.toLowerCase()
  };
  
  // Ê£ÄÊü•ID
  if (el.id && el.id.trim()) {
    const idSelector = `#${CSS.escape(el.id)}`;
    if (isSelectorUnique(idSelector)) {
      stepInfo.selector = idSelector;
      stepInfo.type = 'ID';
      stepInfo.isUnique = true;
      stepInfo.specificity = 100;
      stepInfo.directSelector = idSelector;
      stepInfo.flexibleSelector = idSelector;
      return stepInfo;
    }
  }
  
  // Ê£ÄÊü•ÊµãËØïÂ±ûÊÄß
  const testAttributes = ['data-testid', 'data-test', 'data-cy'];
  for (const attr of testAttributes) {
    const value = el.getAttribute(attr);
    if (value && value.trim()) {
      const selector = `[${attr}="${CSS.escape(value)}"]`;
      if (isSelectorUnique(selector)) {
        stepInfo.selector = selector;
        stepInfo.type = 'Test Attribute';
        stepInfo.isUnique = true;
        stepInfo.specificity = 50;
        stepInfo.directSelector = selector;
        stepInfo.flexibleSelector = selector;
        return stepInfo;
      }
    }
  }
  
  // Ê£ÄÊü•ÂîØ‰∏Äclass
  if (el.className && typeof el.className === 'string') {
    const classes = el.className.trim().split(/\s+/).filter(c => c.length > 0);
    
    for (const cls of classes) {
      const selector = `.${CSS.escape(cls)}`;
      if (isSelectorUnique(selector)) {
        stepInfo.selector = selector;
        stepInfo.type = 'Unique Class';
        stepInfo.isUnique = true;
        stepInfo.specificity = 30;
        stepInfo.directSelector = selector;
        stepInfo.flexibleSelector = selector;
        return stepInfo;
      }
    }
    
    // ‰ΩøÁî®Á¨¨‰∏Ä‰∏™class‰Ωú‰∏∫ÁÅµÊ¥ªÈÄâÊã©Âô®
    if (classes.length > 0) {
      stepInfo.flexibleSelector = `${el.tagName.toLowerCase()}.${CSS.escape(classes[0])}`;
      stepInfo.specificity = 2;
    }
  }
  
  // Â¶ÇÊûúÈúÄË¶ÅÁ¥¢ÂºïÊù•Âå∫ÂàÜÂÖÑÂºüÂÖÉÁ¥†
  const siblings = Array.from(el.parentElement?.children || []);
  const sameTagSiblings = siblings.filter(sibling => sibling.tagName === el.tagName);
  
  if (sameTagSiblings.length > 1) {
    const index = sameTagSiblings.indexOf(el) + 1;
    stepInfo.directSelector = `${el.tagName.toLowerCase()}:nth-of-type(${index})`;
    stepInfo.specificity = 2;
  }
  
  return stepInfo;
}

// ÁîüÊàêÂÖÑÂºüÂÖÉÁ¥†ÊÑüÁü•ÁöÑÈÄâÊã©Âô®
function generateSiblingAwareSelectors(el) {
  const selectors = [];
  
  // Ê£ÄÊü•ÊòØÂê¶Âú®Áõ∏‰ººÁöÑÂÖÑÂºüÂÖÉÁ¥†ÂàóË°®‰∏≠
  if (isElementInSimilarSiblingsList(el)) {
    const parentIndexSelectors = generateParentBasedIndexSelector(el);
    selectors.push(...parentIndexSelectors);
  }
  
  return selectors;
}

// ÁîüÊàêÁªìÊûÑË∑ØÂæÑÈÄâÊã©Âô®ÔºàÂ§áÈÄâÊñπÊ°àÔºâ
function generateStructuralPathSelectors(el) {
  const selectors = [];
  
  // ÁîüÊàêÂÆåÊï¥ÁöÑÁªìÊûÑË∑ØÂæÑÔºà‰Ωú‰∏∫ÊúÄÂêéÁöÑÂ§áÈÄâÊñπÊ°àÔºâ
  const fullPath = generateFullStructuralPath(el);
  if (fullPath && isSelectorUnique(fullPath)) {
    selectors.push({
      type: 'Full Structural Path',
      selector: fullPath,
      description: 'ÂÆåÊï¥ÁªìÊûÑË∑ØÂæÑÔºàÂ§áÈÄâÊñπÊ°àÔºâ',
      priority: 15,
      unique: true,
      stable: false,
      specificity: fullPath.split(' ').length
    });
  }
  
  // Âü∫‰∫éÊñáÊú¨ÂÜÖÂÆπÁöÑÈÄâÊã©Âô®Ôºà‰ªÖ‰Ωú‰∏∫ÊúÄÂêéÂ§áÈÄâÔºâ
  const text = el.textContent.trim();
  if (text && text.length > 0 && text.length < 30 && !text.includes('\n')) {
    const textSelector = `${el.tagName.toLowerCase()}:contains("${text}")`;
    selectors.push({
      type: 'Text Content',
      selector: textSelector,
      description: 'Âü∫‰∫éÊñáÊú¨ÂÜÖÂÆπÈÄâÊã©ÔºàÈùûÊ†áÂáÜCSSÔºå‰∏çÊé®ËçêÔºâ',
      priority: 20,
      unique: false,
      stable: false,
      specificity: 1
    });
  }
  
  return selectors;
}

// ÁîüÊàêÂÆåÊï¥ÁöÑÁªìÊûÑË∑ØÂæÑ
function generateFullStructuralPath(el) {
  const path = [];
  let current = el;
  
  while (current && current !== document.body && path.length < 15) {
    let selector = current.tagName.toLowerCase();
    
    // Ê∑ªÂä†class‰ø°ÊÅØÔºàÂ¶ÇÊûúÊúâÔºâ
    if (current.className && typeof current.className === 'string') {
      const classes = current.className.trim().split(/\s+/).filter(c => c.length > 0);
      if (classes.length > 0) {
        selector += `.${CSS.escape(classes[0])}`;
      }
    }
    
    // Ê∑ªÂä†nth-child‰ø°ÊÅØÔºàÂ¶ÇÊûúÊúâÂ§ö‰∏™Áõ∏ÂêåÂÖÉÁ¥†Ôºâ
    const siblings = Array.from(current.parentElement?.children || []);
    const sameTagSiblings = siblings.filter(sibling => sibling.tagName === current.tagName);
    
    if (sameTagSiblings.length > 1) {
      const index = sameTagSiblings.indexOf(current) + 1;
      selector += `:nth-of-type(${index})`;
    }
    
    path.unshift(selector);
    current = current.parentElement;
  }
  
  return path.length > 0 ? path.join(' > ') : null;
}

// È™åËØÅÂπ∂ÊéíÂ∫èÈÄâÊã©Âô®
function validateAndSortSelectors(selectors, targetElement) {
  // ËøáÊª§Âá∫Á°ÆÂÆûÂîØ‰∏ÄÁöÑÈÄâÊã©Âô®
  const validSelectors = selectors.filter(selectorObj => {
    try {
      const elements = document.querySelectorAll(selectorObj.selector);
      return elements.length === 1 && elements[0] === targetElement;
    } catch (e) {
      console.warn('Invalid selector:', selectorObj.selector, e);
      return false;
    }
  });
  
  // Êåâ‰ºòÂÖàÁ∫ßÂíåÁâπÂºÇÊÄßÊéíÂ∫è
  validSelectors.sort((a, b) => {
    // È¶ñÂÖàÊåâ‰ºòÂÖàÁ∫ßÊéíÂ∫è
    if (a.priority !== b.priority) {
      return a.priority - b.priority;
    }
    
    // Â¶ÇÊûú‰ºòÂÖàÁ∫ßÁõ∏ÂêåÔºåÊåâÁâπÂºÇÊÄßÊéíÂ∫èÔºàÁâπÂºÇÊÄßÈ´òÁöÑ‰ºòÂÖàÔºâ
    if (a.specificity !== b.specificity) {
      return b.specificity - a.specificity;
    }
    
    // ÊúÄÂêéÊåâÈÄâÊã©Âô®ÈïøÂ∫¶ÊéíÂ∫èÔºàÁü≠ÁöÑ‰ºòÂÖàÔºâ
    return a.selector.length - b.selector.length;
  });
  
  return validSelectors;
}

// ÁîüÊàêÂü∫‰∫éÁà∂ÂÖÉÁ¥†ÁöÑÁ®≥ÂÆöÈÄâÊã©Âô®Ôºà‰øùÁïôÂéüÊúâÂáΩÊï∞ÔºåÁî®‰∫éÂÖºÂÆπÔºâ
function generateStableParentSelectors(el) {
  const selectors = [];
  let parent = el.parentElement;
  let level = 1;
  
  while (parent && level <= 3) {
    // Â¶ÇÊûúÁà∂ÂÖÉÁ¥†ÊúâIDÔºå‰ΩøÁî®Áà∂ÂÖÉÁ¥†ID + Â≠êÂÖÉÁ¥†Ê†áÁ≠æ
    if (parent.id && parent.id.trim()) {
      const selector = `#${CSS.escape(parent.id)} > ${el.tagName.toLowerCase()}`;
      if (isSelectorUnique(selector)) {
        selectors.push({
          selector: selector,
          description: `ÈÄöËøáÁà∂ÂÖÉÁ¥†IDÈÄâÊã©Ôºà${level}Á∫ßÁà∂ÂÖÉÁ¥†Ôºâ`,
          unique: true,
          stable: true
        });
      }
    }
    
    parent = parent.parentElement;
    level++;
  }
  
  return selectors;
}

// ÁîüÊàêÂ§áÈÄâÊñπÊ°àÈÄâÊã©Âô®
function generateFallbackSelectors(el) {
  const selectors = [];
  let parent = el.parentElement;
  let level = 1;
  
  while (parent && level <= 3) {
    // Â¶ÇÊûúÁà∂ÂÖÉÁ¥†ÊúâIDÔºå‰ΩøÁî®Áà∂ÂÖÉÁ¥†ID + Â≠êÂÖÉÁ¥†Ê†áÁ≠æ
    if (parent.id && parent.id.trim()) {
      const selector = `#${CSS.escape(parent.id)} > ${el.tagName.toLowerCase()}`;
      if (isSelectorUnique(selector)) {
        selectors.push({
          selector: selector,
          description: `ÈÄöËøáÁà∂ÂÖÉÁ¥†IDÈÄâÊã©Ôºà${level}Á∫ßÁà∂ÂÖÉÁ¥†Ôºâ`,
          unique: true,
          stable: true
        });
      }
    }
    
    // Â¶ÇÊûúÁà∂ÂÖÉÁ¥†ÊúâÁ®≥ÂÆöÁöÑclassÔºå‰ΩøÁî®Áà∂ÂÖÉÁ¥†class + Â≠êÂÖÉÁ¥†Ê†áÁ≠æ
    if (parent.className && typeof parent.className === 'string') {
      const parentClasses = parent.className.trim().split(/\s+/).filter(c => c.length > 0);
      for (const cls of parentClasses) {
        const selector = `.${CSS.escape(cls)} > ${el.tagName.toLowerCase()}`;
        if (isSelectorUnique(selector)) {
          selectors.push({
            selector: selector,
            description: `ÈÄöËøáÁà∂ÂÖÉÁ¥†classÈÄâÊã©Ôºà${level}Á∫ßÁà∂ÂÖÉÁ¥†Ôºâ`,
            unique: true,
            stable: true
          });
          break; // ÊâæÂà∞‰∏Ä‰∏™Á®≥ÂÆöÁöÑÂ∞±Â§ü‰∫Ü
        }
      }
    }
    
    // Â¶ÇÊûúÁà∂ÂÖÉÁ¥†ÊúâÊµãËØïÂ±ûÊÄßÔºå‰ΩøÁî®ÊµãËØïÂ±ûÊÄß + Â≠êÂÖÉÁ¥†Ê†áÁ≠æ
    const testAttributes = ['data-testid', 'data-test', 'data-cy'];
    for (const attr of testAttributes) {
      const value = parent.getAttribute(attr);
      if (value && value.trim()) {
        const selector = `[${attr}="${CSS.escape(value)}"] > ${el.tagName.toLowerCase()}`;
        if (isSelectorUnique(selector)) {
          selectors.push({
            selector: selector,
            description: `ÈÄöËøáÁà∂ÂÖÉÁ¥†ÊµãËØïÂ±ûÊÄßÈÄâÊã©Ôºà${level}Á∫ßÁà∂ÂÖÉÁ¥†Ôºâ`,
            unique: true,
            stable: true
          });
          break;
        }
      }
    }
    
    parent = parent.parentElement;
    level++;
  }
  
  return selectors;
}

// ÁîüÊàêÂ§áÈÄâÈÄâÊã©Âô®ÔºàÂΩìÊ≤°ÊúâÁ®≥ÂÆöÈÄâÊã©Âô®Êó∂‰ΩøÁî®Ôºâ
function generateFallbackSelectors(el) {
  const selectors = [];
  
  // Âü∫‰∫éÊ†áÁ≠æÂêçÂíåÊñáÊú¨ÂÜÖÂÆπÁöÑÁªÑÂêà
  const text = el.textContent.trim();
  if (text && text.length > 0 && text.length < 50) {
    const textSelector = `${el.tagName.toLowerCase()}:contains("${text}")`;
    selectors.push({
      selector: textSelector,
      description: `Âü∫‰∫éÊ†áÁ≠æÂíåÊñáÊú¨ÂÜÖÂÆπÔºàÈùûÊ†áÂáÜCSSÔºâ`,
      unique: false,
      stable: false
    });
  }
  
  // Âü∫‰∫éÊ†áÁ≠æÂêçÂíåÂ±ûÊÄßÁöÑÁªÑÂêà
  const attributes = ['type', 'role', 'aria-label'];
  for (const attr of attributes) {
    const value = el.getAttribute(attr);
    if (value && value.trim()) {
      const selector = `${el.tagName.toLowerCase()}[${attr}="${CSS.escape(value)}"]`;
      selectors.push({
        selector: selector,
        description: `Âü∫‰∫éÊ†áÁ≠æÂíå${attr}Â±ûÊÄß`,
        unique: false,
        stable: true
      });
    }
  }
  
  // Âü∫‰∫é‰ΩçÁΩÆÁöÑÁõ∏ÂØπÈÄâÊã©Âô®ÔºàÊúÄÂêéÁöÑÈÄâÊã©Ôºâ
  const positionSelector = generatePositionSelector(el);
  if (positionSelector) {
    selectors.push({
      selector: positionSelector,
      description: `Âü∫‰∫é‰ΩçÁΩÆÁöÑÈÄâÊã©Âô®Ôºà‰∏çÁ®≥ÂÆöÔºå‰∏çÊé®ËçêÔºâ`,
      unique: false,
      stable: false
    });
  }
  
  return selectors;
}

// ÁîüÊàêÂü∫‰∫é‰ΩçÁΩÆÁöÑÈÄâÊã©Âô®Ôºà‰∏çÊé®ËçêÔºå‰ΩÜ‰Ωú‰∏∫ÊúÄÂêéÂ§áÈÄâÔºâ
function generatePositionSelector(el) {
  const path = [];
  let current = el;
  
  while (current && current.nodeType === Node.ELEMENT_NODE && path.length < 4) {
    let selector = current.tagName.toLowerCase();
    
    // ËÆ°ÁÆóÂú®ÂêåÁ±ªÂûãÂÖÑÂºüÂÖÉÁ¥†‰∏≠ÁöÑ‰ΩçÁΩÆ
    let position = 1;
    let sibling = current.previousElementSibling;
    while (sibling) {
      if (sibling.tagName === current.tagName) {
        position++;
      }
      sibling = sibling.previousElementSibling;
    }
    
    if (position > 1) {
      selector += `:nth-of-type(${position})`;
    }
    
    path.unshift(selector);
    current = current.parentElement;
  }
  
  return path.length > 1 ? path.join(' > ') : null;
}

// Get element position and size
function getElementBounds(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top + window.scrollY,
    left: rect.left + window.scrollX,
    width: rect.width,
    height: rect.height
  };
}

// Highlight element
function highlightElement(element, highlightBox, infoPanel) {
  const bounds = getElementBounds(element);
  const selectors = generateMultipleSelectors(element);
  const text = element.textContent.trim().substring(0, 100);
  
  // Position highlight box
  highlightBox.style.display = 'block';
  highlightBox.style.top = bounds.top + 'px';
  highlightBox.style.left = bounds.left + 'px';
  highlightBox.style.width = bounds.width + 'px';
  highlightBox.style.height = bounds.height + 'px';
  
  // Update current element info
  const elementDetails = infoPanel.querySelector('#element-details');
  if (elementDetails) {
    const bestSelector = selectors[0];
    const selectorInfo = bestSelector ? 
      `${bestSelector.selector} ${bestSelector.unique ? '‚úÖ' : '‚ö†Ô∏è'} ${bestSelector.stable ? 'üîí' : '‚ö†Ô∏è'}` : 
      'N/A';
    
    elementDetails.innerHTML = `
      <div style="margin-bottom: 3px;"><strong>Tag:</strong> ${element.tagName.toLowerCase()}</div>
      <div style="margin-bottom: 3px;"><strong>Text:</strong> ${text}${element.textContent.length > 100 ? '...' : ''}</div>
      <div style="margin-bottom: 3px;"><strong>Best Selector:</strong> ${selectorInfo}</div>
      <div style="margin-top: 5px; font-size: 10px; opacity: 0.8;">
        Click to select ‚Ä¢ ESC to cancel<br>
        ‚úÖ Unique ‚Ä¢ üîí Stable ‚Ä¢ ‚ö†Ô∏è Not recommended
      </div>
    `;
  }
  
  // Show info panel
  infoPanel.style.display = 'block';
}

// Hide highlight
function hideHighlight(highlightBox, infoPanel) {
  highlightBox.style.display = 'none';
  infoPanel.style.display = 'none';
}

// Main selection logic
function startElementSelection() {
  if (!isExtensionContextValid()) {
    console.log('Extension context invalidated');
    return;
  }

  // Check if selection is already active
  if (window.clickScrapeActive) {
    console.log('Selection already active');
    return;
  }

  // Create UI elements
  const overlay = createOverlay();
  const highlightBox = createHighlightBox();
  const infoPanel = createInfoPanel();
  
  window.clickScrapeActive = true;
  let currentElement = null;

  // Show overlay
  overlay.style.display = 'block';
  infoPanel.style.display = 'block';
  
  // Load history with a small delay to ensure DOM is ready
  setTimeout(() => {
    loadAndDisplayHistory();
  }, 10);

  // Mouse move handler
  window.clickScrapeMouseMove = function(event) {
    if (!window.clickScrapeActive) return;
    
    // Skip element detection if mouse is over the info panel
    if (window.clickScrapePanelHover) {
      return;
    }
    
    const element = document.elementFromPoint(event.clientX, event.clientY);
    
    // Double-check that the element is not part of the info panel
    if (element && element.closest('#click-scrape-info')) {
      return;
    }
    
    if (element && element !== currentElement) {
      currentElement = element;
      highlightElement(element, highlightBox, infoPanel);
    }
  };

  // Click handler
  window.clickScrapeClick = function(event) {
    if (!window.clickScrapeActive) return;
    
    // Skip if mouse is over panel or click is on panel
    if (window.clickScrapePanelHover) {
      return;
    }
    
    // Check if the click is on a button in the info panel
    const target = event.target;
    if (target && (target.id === 'clear-history' || target.id === 'close-panel' || target.closest('#click-scrape-info'))) {
      // Don't handle clicks on panel buttons
      return;
    }
    
    event.preventDefault();
    event.stopPropagation();
    
    if (currentElement) {
      const elementText = currentElement.textContent.trim();
      const selectors = generateMultipleSelectors(currentElement);
      
      const elementData = {
        text: elementText,
        selectors: selectors,
        tagName: currentElement.tagName.toLowerCase(),
        attributes: Array.from(currentElement.attributes).map(attr => `${attr.name}="${attr.value}"`).join(' ')
      };
      
      // Save to localStorage history
      saveToHistory(elementData);
      
      // Auto-copy best selector to clipboard
      const bestSelector = selectors[0] ? selectors[0].selector : '';
      if (bestSelector) {
        navigator.clipboard.writeText(bestSelector).then(() => {
          console.log('Selector auto-copied to clipboard:', bestSelector);
        }).catch(err => {
          console.error('Failed to auto-copy selector to clipboard:', err);
        });
      }
      
      // Send data to background script
      try {
        chrome.runtime.sendMessage({
          action: 'elementClicked',
          data: elementData
        });
      } catch (error) {
        console.log('Error sending message:', error);
      }
      
      // Show success feedback
      const elementDetails = infoPanel.querySelector('#element-details');
      if (elementDetails) {
        const originalContent = elementDetails.innerHTML;
        elementDetails.innerHTML = `
          <div style="color: #90EE90; font-weight: bold; margin-bottom: 5px;">‚úÖ Element Selected!</div>
          <div style="margin-bottom: 3px;"><strong>Tag:</strong> ${currentElement.tagName.toLowerCase()}</div>
          <div style="margin-bottom: 3px;"><strong>Text:</strong> ${elementText.substring(0, 50)}${elementText.length > 50 ? '...' : ''}</div>
          <div style="margin-bottom: 3px;"><strong>Best Selector:</strong> ${selectors[0] ? selectors[0].selector : 'N/A'}</div>
          <div style="color: #87CEEB; font-size: 10px; margin-bottom: 3px;">üìã Selector auto-copied to clipboard!</div>
          <div style="margin-top: 5px; font-size: 10px; opacity: 0.8;">Continue selecting or press ESC to exit</div>
        `;
        
        // Restore original content after 2 seconds
        setTimeout(() => {
          if (window.clickScrapeActive) {
            elementDetails.innerHTML = originalContent;
          }
        }, 2000);
      }
    }
    
    // Don't cleanup - keep selection mode active
  };

  // Escape key handler
  window.clickScrapeKeyDown = function(event) {
    if (event.key === 'Escape') {
      cleanup();
    }
  };

  // Cleanup function
  function cleanup() {
    window.clickScrapeActive = false;
    window.clickScrapePanelHover = false; // Reset panel hover state
    overlay.style.display = 'none';
    hideHighlight(highlightBox, infoPanel);
    
    // Remove event listeners
    document.removeEventListener('mousemove', window.clickScrapeMouseMove);
    document.removeEventListener('click', window.clickScrapeClick, true);
    document.removeEventListener('keydown', window.clickScrapeKeyDown);
    
    // Remove UI elements
    setTimeout(() => {
      if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
      if (highlightBox.parentNode) highlightBox.parentNode.removeChild(highlightBox);
      if (infoPanel.parentNode) infoPanel.parentNode.removeChild(infoPanel);
    }, 100);
  }

  // Add event listeners
  document.addEventListener('mousemove', window.clickScrapeMouseMove);
  document.addEventListener('click', window.clickScrapeClick, true);
  document.addEventListener('keydown', window.clickScrapeKeyDown);
  
  console.log('Element selection started. Hover over elements and click to select, or press ESC to cancel.');
}


// Check if this script has already been injected
if (!window.clickScrapeInjected) {
  window.clickScrapeInjected = true;
  
  // Listen for messages from background script to start selection
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'startSelection') {
      startElementSelection();
      sendResponse({ success: true });
    }
  });
  
  console.log('Click & Scrape content script loaded');
}
  
  